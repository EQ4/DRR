<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>About Indycast - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Lora' rel='stylesheet' type='text/css'>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
  body { background: url('images/crossword.png'); }
  * { font-family: 'Lora', serif; }
  p {
    max-width: 700px;
    margin-left: 10px;
    line-height: 1.4em;
  }
  #logo {
    float: left;
    margin-left: 10px;
    width: 70px;
    height: 90px;
  }
  #title { 
    margin-top: 20px;
  }
  #logo-block {
    margin-left: 30px;
  }
  #logo-block img {
    border: 1px solid rgba(128,128,128,0.5);
    margin: 2px;
    padding: 2px;
  }
  #header {
    margin-left: 90px;
    height: 90px;
  }
  #header * { 
    margin: 0;
  }
  h1,h2,h3,h4,h5,h6 {
    color: #002244;
  }
  h2 { margin-left: 10px; }
  h3 { margin-left: 20px; }
  h4 { margin-left: 40px; }
  
  h2 ~ p {
    margin-left: 20px;
  }
  h3 ~ table, h3 ~ p, h3 ~ ul, h3 ~ ol, h3 ~ pre {
    margin-left: 40px;
  }
  th, td {
    padding-right: 12px;
  }
  li {
    line-height: 1.3em
  }
  code, pre{
    font-family: 'Inconsolata', monospace;
  }
  pre {
    display: inline-block;
    line-height: 1.5em;
    width: auto;
    background: #f8fafd;
    box-shadow: 0 0 2px 0px #ddd inset;
    padding: 0.75em 1em;
    border-radius: 5px;
    margin: 0 1em;
  }
  code {
    text-shadow: 0px 0px 1px #aaa;
  }
  pre > code {
    text-shadow: 0 0;
  }
  blockquote {
    border-left: 4px solid #eef;
  }
  </style>
</head>
<body>
<div id="title">
<div id="logo">
<img src=images/square-indycast_70.png>
</div>
<div id="header">
<h1>
Indycast
</h1>
<h2>
A Distributed Open Source DVR for Independent Radio
</h2>
</div>
</div>
<h2 id="introduction">Introduction</h2>
<p>Indycast is a set of community owned federated servers for time-shifting independent radio because</p>
<ul>
<li>Often the best shows are on at inconvenient hours</li>
<li>Shows are rarely archived</li>
<li>When shows are archived, they often have the following properties
<ul>
<li>A proprietary solution such as iTunes is required.</li>
<li>They are broken into small units that must be reconstituted manually.</li>
<li>Every show and station has a different website with a different layout.</li>
<li>The retention policy of the audio and when it is availabe widely varies.</li>
</ul></li>
</ul>
<p>Essentially the existing landscape is laborious to use, inconsistent, technically restricted, and very incomplete in coverage.</p>
<h2 id="making-things-easy-and-powerful">Making things easy and powerful</h2>
<p>The project's objectives:</p>
<ul>
<li><strong>Non-commercial:</strong> A way to provide listener-supported radio in a convenient manner.</li>
<li><strong>Free:</strong> Trying to build a community instead of always looking to make a buck.</li>
<li><strong>Distributed:</strong> People from other places can join the network using their stations without much effort.</li>
<li><strong>Hackable:</strong> Every device and reasonable way of listening to content is supported.</li>
</ul>
<h2 id="architecture">Architecture</h2>
<p>There's no money behind this. It's designed to be cheap with a low barrier to entry for participation. People are encouraged to run and manage their own servers for their favorite radio station.</p>
<p>The solution seeks to be:</p>
<ul>
<li><strong>Simple</strong>: Easy and quick to setup.</li>
<li><strong>Small</strong>: A small-footprint, unobtrusive system that can piggy-back on servers doing other things.</li>
<li><strong>Customizable</strong>: Highly configurable with reasonable defaults.</li>
<li><strong>Efficient</strong>: Able to be use minimal disk and network resources.</li>
<li><strong>Self-contained</strong>: Able to be run multiple times on the same machine for different stations.</li>
</ul>
<p>It also is not:</p>
<ul>
<li>Requiring of significant dependencies.</li>
<li>Be language-specific with arcane knowledge needed in order to get it running.</li>
</ul>
<p>It's in Python 2.7, Flask, and SQLite 3. The audio library is written by hand (more below on why)</p>
<h2 id="user-experience">User-experience</h2>
<h3 id="being-an-administrator">Being an administrator</h3>
<p>The ideal user-experience of someone who wants to participate.</p>
<h4 id="easy-set-up">Easy set-up</h4>
<p>Alice, a junior dev, is interested in adding her station, RDIO. She</p>
<ol style="list-style-type: decimal">
<li>Git clones <a href="https://github.com/kristopolous/DRR">the repository</a>.</li>
<li>Runs a <a href="https://github.com/kristopolous/DRR/blob/master/bootstrap.sh">small shell script</a> <code>bootstrap.sh</code> to install dependencies.</li>
<li>Goes to RDIO's website and finds the live stream url.</li>
<li>Puts the URL in a configuration file, say <code>server/configs/rdio.txt</code>.</li>
<li>Runs the server with this configuration file, <code>server/indy_server.py -c server/configs/rdio.txt</code>.</li>
</ol>
<h4 id="self-contained">Self-contained</h4>
<p>When the server starts up, it</p>
<ul>
<li>Puts everything in a single directory with a simple to understand hierarchy: <code>~/radio/rdio/</code></li>
<li>Forks processes from a manager thread, carefully naming them with their purpose.</li>
<li>Has an informative log file that tells the user what's going on: <code>~/radio/rdio/indycast.log</code></li>
<li>Is easy to shut down and restart: <code>kill cat ~/radio/rdio/pid-manager</code></li>
<li>Is remotely upgradable (through the <code>/upgrade</code> endpoint), replacing its own footprint seamlessly.</li>
</ul>
<h4 id="non-mysterious">Non-mysterious</h4>
<p>There's an endpoint map so Alice can see everything that is accessible along with its documentation. As of the writing of this document, it looks like so:</p>
<pre><code>$ curl indycast.net/kpcc/site-map
/heartbeat      
    A low resource version of the /stats call ... this is invoked
    by the server health check.  Only the uptime of the server is reported.
    
    This allows us to check if a restart happened between invocations.
    

/site-map        
    Shows all the end points supported by the current server, the options 
    and the documentation.
    

/reindex         
    Starts the prune process which cleans up and offloads audio files but also re-index 
    the database.

    This is useful in the cases where bugs have led to improper registration of the 
    streams and a busted building of the database.  It&#39;s fairly expensive in I/O costs 
    so this shouldn&#39;t be done as the default.
    

/restart         
    Restarts an instance. This does so in a gapless non-overlapping way.
    

/upgrade        
    Goes to the source directory, pulls down the latest from git
    and if the versions are different, the application restarts.
    

/prune           
    Starts the prune sub-process which cleans up and offloads audio files 
    following the rules outlined in the configuration file (viewable with the stats call)
    

/stats           
    Reports various statistical metrics on a particular server.  
    Use this with the graph.py tool to see station coverage.
    

/uuid            
    Returns this server&#39;s uuid which is generated each time it is run.
    This is used to determine whether this is the official server or not.
    

/db              
    Backs up the current sqlite3 db and sends a gzipped version of it as the response.
    

/[weekday]/[start]/[duration_string]/[showname] 
    Returns a podcast xml file based on the weekday, start and duration.
    This is designed to be read by podcasting software such as podkicker, 
    itunes, and feedburner.

    weekdays are defined as mon, tue, wed, thu, fri, sat, sun.

    If a show occurs multiple times per week, this can be specified with
    a comma.  for instance,

    /mon,tue,fri/4pm/1hr
    
    The showname should be followed by an &quot;xml&quot; extension.

    It should also be viewable in a modern web browser.

    If you can find a podcaster that&#39;s not supported, please send an email 
    to indycast@googlegroups.com.
    

/at/[start]/[duration_string] 
    Sends a stream using a human-readable (and human-writable) definition 
    at start time.  This uses the dateutils.parser library and so strings 
    such as &quot;Monday 2pm&quot; are accepted.

    Because the space, 0x20 is such a pain in HTTP, you can use &quot;_&quot;, 
    &quot;-&quot; or &quot;+&quot; to signify it.  For instance,

        /at/monday_2pm/1hr

    Will work fine
    

/slices/[path] 
    Downloads a stream from the server. The path is callsign-date_duration.mp3

      * callsign: The callsign returned by /stats
      * date: in the format YYYYMMDDHHMM such as 201508011005 for 
        2015-08-01 10:05
      * duration: A value, in minutes, to return.

    The mp3 extension should be used regardless of the actual format of the stream -
    although the audio returned will be in the streams&#39; native format.
    
    The streams are created and sent on-demand, so there may be a slight delay before
    it starts.
    

/live/[start]  
    Sends off a live-stream equivalent.  Two formats are supported:

     * duration - In the form of strings such as &quot;1pm&quot; or &quot;2:30pm&quot;
     * offset - starting with a negative &quot;-&quot;, this means &quot;from the present&quot;.
        For instance, to start the stream from 5 minutes ago, you can do &quot;-5&quot;</code></pre>
<p>These endpoints can be conveniently queried in bulk using a server query tool, located in <code>tools/server_query.py</code>. It can query any endpoint on any number of stations and parse JSON if desired. For instance, if I wanted to see how much disk space kpcc is using I can do the following:</p>
<pre><code>$ tools/server_query.py -k disk -c kpcc
{&quot;url&quot;: &quot;kpcc.indycast.net:8930&quot;, &quot;latency&quot;: 2.824465036392212, &quot;disk&quot;: 2000112}</code></pre>
<p>Or, if I wanted to find out the uptime and disk space of kpcc and kxlu:</p>
<pre><code>$ tools/server_query.py -k disk,uptime -c kpcc,kxlu
[
{&quot;url&quot;: &quot;kxlu.indycast.net:8890&quot;, &quot;latency&quot;: 3.542130947113037, &quot;uptime&quot;: 5235, &quot;disk&quot;: 2283312},
{&quot;url&quot;: &quot;kpcc.indycast.net:8930&quot;, &quot;latency&quot;: 2.451361894607544, &quot;uptime&quot;: 5250, &quot;disk&quot;: 2000112}
]</code></pre>
<p>As you can see, the server query presents this in a JSON array for our convenience.</p>
<p>If you'd like to find out what the station coverage is, there's a graph-drawing tool that tells you.</p>
<pre><code>$ tools/server_query.py -q stats -c kpcc | tools/graph.py 

         +-0---1---2---3---4---5---6---7---8---9---10--11--12--13--14--15--16--17--18--19--20--21--22--23--+
2015-07-06 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . |
2015-07-07 *=******.*********************************************.**************************************** |
2015-07-08 ************************************************* **********************************************|
2015-07-09 .***********************************.********************************************************** |
2015-07-10 ******************************************************* *******=******************************* |
2015-07-11 **************.**************** .*********************************.**************************** |
2015-07-12 ***************** *********************************************************************** ******|
2015-07-13 .********************** ***********************************=****************.*******************|
2015-07-14 .***************.*****************.******** ****************************************************|
2015-07-15 .***********************************************************************************************|
2015-07-16 . *********=********************=*******************=**********************************=********|
2015-07-17 .************** ***** ********************************************************* ******* ******* |
2015-07-18 *********************************************** ****************. . . . . . . . . . .***********|
2015-07-19 .***********************************************************************************************|
2015-07-20 .***********************************************************************************************|
2015-07-21 .***********************************************************************************************|
2015-07-22 .***********************.***********************************************.********************** |
2015-07-23 .****************************************************************============*************.** **|
2015-07-24 ************************************************************************====. . . . . . . ******|
2015-07-25 .***.**** ***************************** *************** .******************** ************.*****|
2015-07-26 .*********************************************************************.************ ********.***|
2015-07-27 .****==== ******************************* **********************.*********.*************.*******|
2015-07-28 .****** *************************** *********************** *********************************** |
2015-07-29 ***************************************************======*************===************ ********* |
2015-07-30 ************* ******************************=========*******.****** .*.************************ |
2015-07-31 .************************************************** ******************.************************ |
2015-08-01 *********************************************************************************************=* |
2015-08-02 **=*************************==************* .**** ********************************************* |
2015-08-03 *** ***** *********************************** ********* ******.** *** *******=======*********** |
2015-08-04 ********.**************************************************** . . . . . . . . . . . . . . . . . |
         +-0---1---2---3---4---5---6---7---8---9---10--11--12--13--14--15--16--17--18--19--20--21--22--23--+

         kpcc coverage: 90.877315%</code></pre>
<h3 id="being-a-user">Being a User</h3>
<p>The user of the service should be able to use the service in any reasonable way with any reasonable set of expectations.</p>
<h4 id="should-be-usable-by-novices">Should be usable by novices</h4>
<p>If Alice doesn't really know how to use computers that well, there is a <a href="http://indycast.net">web front end</a> that explains what indycast is and has a simple and attractive user-interface that she can operate on the device of her choosing.</p>
<p>However, Alice is a hacker. She has no problem using a command line.</p>
<p>She's in luck. Powerful things can be done in simple ways using the command line.</p>
<p>The first thing that Alice does is curl the main indycast site.</p>
<p>Normally this is a stupid idea as she would get a bunch of terribly formatted server-generated HTML, but not with indycast! Here is what she sees:</p>
<pre><code>$ curl http://indycast.net/    
The current stations are healthy:

 * http://indycast.net/kcrw/
 * http://indycast.net/kdvs/
 * http://indycast.net/kpcc/
 * http://indycast.net/kpfk/
 * http://indycast.net/kspc/
 * http://indycast.net/kusf/
 * http://indycast.net/kvrx/
 * http://indycast.net/kxlu/
 * http://indycast.net/kzsu/
 * http://indycast.net/wcbn/
 * http://indycast.net/wfmu/
 * http://indycast.net/wxyc/
 * http://indycast.net/wzrd/

Query the /site-map end-point to see
supported features on a per-station basis.

Thanks for using curl/7.26.0 ;-).
$</code></pre>
<p>Finally someone cares about the hackers. She can easily copy and paste the stubs to access the API.</p>
<h4 id="subscribe-to-any-show">Subscribe to any show</h4>
<p>XMLs podcasts feed are generated with a simple url schema:</p>
<pre><code>http://indycast.net/[station]/[weekday,...]/[start time]/[duration]/[name]</code></pre>
<p>For instance, if there's a 2 hour show called, say &quot;Darkwaves&quot; at 2AM monday and wednesday mornings, you could do:</p>
<pre><code>http://indycast.net/rdio/mon,wed/2am/2hr/Darkwaves.xml</code></pre>
<p>And that url should be openable in anything that ostensibly accepts so called <em>podcasts</em>.</p>
<p>Or if you prefer, since the XML gets printed in a human readable pretty-print form, you can just cut the BS and do something like this:</p>
<pre><code>$ curl -s kxlu.indycast.net:8890/sun/7pm/1hr/show.xml | grep enclosure 
  &lt;enclosure url=&quot;http://kxlu.indycast.net:8890/slices/kxlu-201507261900_62.mp3&quot; length=&quot;59520000&quot; type=&quot;audio/mpeg&quot;/&gt;
  &lt;enclosure url=&quot;http://kxlu.indycast.net:8890/slices/kxlu-201508021900_62.mp3&quot; length=&quot;59520000&quot; type=&quot;audio/mpeg&quot;/&gt;
$</code></pre>
<p>Just like a boss. Alice is a boss.</p>
<p>BTW, the audio intentionally starts a bit early and goes a bit over because in the real world, shows don't end on some exact NTP millisecond.</p>
<h4 id="rewind-pause-and-scrub-live-radio">Rewind, pause, and scrub live radio</h4>
<p>Alice turns on her radio and there's a fascinating interview going on. Unfortunately, she missed the beginning of it. Luckily, she is able to listen to RDIO starting say, 5 minutes ago, by doing the following:</p>
<pre><code>$ mplayer http://indycast.net/rdio/live/-5min</code></pre>
<p>Or, if she wants to listen starting at 1pm, this works:</p>
<pre><code>$ mpg321 http://indycast.net/rdio/live/1pm</code></pre>
<h4 id="pick-any-arbitrary-time-slice">Pick any arbitrary time slice</h4>
<p>If Alice just wants to listen to say, the Darkwaves show directly, from the command line, without all the hassle, she can specify a date, time, and duration, such as this:</p>
<pre><code>$ mplayer2 http://indycast.net/rdio/at/monday_2am/2hr</code></pre>
<h4 id="logos">Logos</h4>
<p>Logos for the podcasts are generated server-side at indycast.net so as not to require any image-processing or font dependencies on the servers themselves. The background tint is chosen based on the word itself in order to create a diverse but distinct palette for the various logos.</p>
<p>The schema for generating them looks like the following</p>
<pre><code>http://indycast.net/icon/(Arbitrary_string)_(size).png</code></pre>
<p>For instance:</p>
<pre><code>&lt;img src=http://indycast.net/icon/Here+is+one_120.png&gt;
&lt;img src=http://indycast.net/icon/And+here+is+another_120.png&gt;
&lt;img src=http://indycast.net/icon/You+can+go+small_90.png&gt;</code></pre>
<p>Looks like so:</p>
<div id="logo-block">
<p><img src=http://indycast.net/icon/Here+is+one_120.png><img src=http://indycast.net/icon/And+here+is+another_120.png><img src=http://indycast.net/icon/You+can+go+small_90.png></p>
</div>
<p>The logos are 16-color PNGs which make them small and fast (although admittedly kind of ugly).</p>
<h2 id="fast-and-small">Fast and small</h2>
<h3 id="disk-space-efficient">Disk space efficient</h3>
<p>VPSs generally don't give that much disk space and archiving audio would normally take a lot of it.</p>
<p>That's why there's support for cloud storage. A survey was done to try to find the cheapest storage options:</p>
<ul>
<li>Amazon EC2: $0.050 / GB</li>
<li>Google Compute: $0.040 / GB</li>
<li>Microsoft Azure: $0.024 / GB</li>
</ul>
<p>Coming in at less than half the price of EC2, MS Azure was the obvious choice. If configured with credentials, the server will use an Azure account to offload the valuable disk space on the VPS. If you would rather use another service, <a href="https://github.com/kristopolous/DRR/issues">open a bug</a>.</p>
<p>A tool <code>tools/cloud.py</code> computes the current cost for the stations specified. Also, a tool <code>tools/cleanup_cloud.sh</code> will analyze all the content on the cloud and make sure that it's valid and in use. Here is an example:</p>
<pre><code>$ tools/cloud.py

 Station   Files   Space (GB)
-----------------------------
14: kcrw   1738    22.467
13: kdvs   1938    25.881
12: kpcc   2792    18.477
11: kpfk   5000     4.069
10: krvm    341     3.470
 9: kspc   1508    20.169
 8: kusf    865    11.661
 7: kvrx   2693    54.312
 6: kxlu   2661    35.260
 5: kzsu   4273    35.511
 4: wcbn   2681    34.591
 3: wfmu   1717    23.250
 2: wxyc   1114    14.798
 1: wzrd   1038     3.368
-----------------------------
 Total    30359   307.282 GB
 Cost     $7.37/month

 *using $0.024/GB azure pricing</code></pre>
<h3 id="cpu-efficient">CPU efficient</h3>
<p>There is no audio processing done.</p>
<p>Because audio streams are just binary files, and the binary files are identical independent of the user downloading them, then in order to overlap or splice the audio all you need is the ability to parse and find the headers ... not the payloads themselves.</p>
<p>Since there was no library out there that did just the headers, one was written for this. It scans headers, hopping around the file, making a number of assumptions about things (such as CBR encoding) and as a result, audio can be brought down from the cloud storage, stitched together, and then sliced in under a second.</p>
<p>Generally speaking, since the user is expecting to hear 1 or 2 hours of audio, this delay doesn't feel unusual.</p>
<p>Bitrates are computed based on how many bits transit over the connection in a given duration as opposed to being internally taken from the file itself. This is a much more direct computation and the sample size is large enough to avoid any errors.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you enjoyed reading this and use indycast. I've been working full-time, 7 days a week on it since June 2015 and encourage you to become part of the community.</p>
<p>If there are stations you'd like to support, or better yet, money you'd like to donate, <a href="https://github.com/kristopolous/DRR/wiki">a wiki has been set up</a> describing:</p>
<ul>
<li>How to run your own server</li>
<li>The current cost and server architecture</li>
</ul>
<p>I also encourage you to <a href="https://github.com/kristopolous/DRR">pull down the code</a> which I have taken a serious effort on to be consistent and well-documented. If you find issues, please feel free to send a pull-request.</p>
<p>Thanks for reading.</p>
<p>~chris.</p>
</body>
</html>
